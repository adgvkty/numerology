# Справка по уроку №5
Интерфейс — это абстракция, позволяющая определить желаемое поведение, не реализуя его самостоятельно и без указания на конкретную реализацию.

Для объявления интерфейсного типа используется ключевое слово `interface{}`:

```Go
type [имя интерфейса] interface{
    [требуемое поведение интерфейса]
}

type jivotnoe interface{
    bark()
}
```

Интерфейс не является конкретным типом, вроде `int` или `struct{}`, поэтому нельзя создать объект интерфейсного типа напрямую:

```Go
// данный код не скомпилируется
var ji jivotnoe = jivotnoe{}
```

Интерфейс это некий шаблон, которому должен строго соответствовать нужный нам тип данных. Чтобы тип удовлетворял интерфейс, его методы должны реализовывать **все указанные нами** в интерфейсе **функции**:

```Go
package main

import "fmt"

// наш «шаблон», которому должны соответствовать
// пользовательские типы данных
type jivotnoe interface {
	bark()
}

// первый тип данных
type dogee struct{}

// и его метод, удовлетворяющий интерфейсу jivotnoe{}
func (d dogee) bark() {
	fmt.Println("sobaka delaet gav gav")
}

// второй тип данных
type chelik struct{}

// и метод, так же удовлетворяющий интерфейсу jivotnoe{}
func (c chelik) bark() {
	fmt.Println("chelik delaet gav gav")
}

func main() {

	// обе переменные имеют интерфейсный тип данных
	//
	// присваиваемые в них значения должны соответствовать
	// указанному интерфейсу (в нашем случае — jivotnoe{})
	var bobik jivotnoe = dogee{}
	var grisha jivotnoe = chelik{}

	// вызываем метод интерфейса
	bobik.bark()
	grisha.bark()
}
```

>В отличии от многих языков программирования, в Go интерфейсы **реализуются неявно**. Специально указывать, что наши типы соответствуют определенному интерфейсу, не нужно. Компилятору языка достаточно того, что нужные методы наших типов **будут объявлены** — сопоставление он сделает сам.

Интерфесы в разработке необходимы там, где нам необходимо определить **обобщенную реализацию** функционала, не зависящую от конкретного типа. Интерфейсу не важно, что «под капотом» у типа, который ему удовлетворяет — лишь бы нужные методы были реализованы. 

Такой подход предполагает некий **слой изоляции**, который может помочь нам в упрощении кода или создании «чистой», слабосвязанной архитектуры:

```Go
package main

import "fmt"

type dogee struct{}

func (d dogee) bark() {
	fmt.Println("sobaka delaet gav gav")
}

type chelik struct{}

func (c chelik) bark() {
	fmt.Println("chelik delaet gav gav")
}

// вызываем метод для лая собачки
func callDogee(d dogee) {
	d.bark()
}

// вызываем метод для лая челика
func callChelik(c chelik) {
	c.bark()
}

func main() {

	var bobik dogee = dogee{}
	var grisha chelik = chelik{}

    // обе эти функции идентичны
    // и их обязательно нужно оптимизировать
	callDogee(bobik)
	callChelik(grisha)
}
```

Если мы сможем определить одну обобщенную функцию для разных типов, наш код станет чище. Тем более, что bark() из интерфейса jivotnoe{} могут реализовывать и другие сущности, которые мы пока не объявили. И именно в таких случаях обоснованно использовать интерфейс:

```Go
package main

import "fmt"

type jivotnoe interface {
	bark()
}

type dogee struct{}

func (d dogee) bark() {
	fmt.Println("sobaka delaet gav gav")
}

type chelik struct{}

func (c chelik) bark() {
	fmt.Println("chelik delaet gav gav")
}

// вместо двух идентичных функций
// мы реализуем одну функцию, принимающую аргументом
// наш интерфейсный тип
//
// таким образом, мы сможем вызвать эту функцию, передав ей
// аргументом любой тип, удовлетворяющий интерфейсу
func call(j jivotnoe) {
	j.bark()
}

func main() {

	bobik, grisha := dogee{}, chelik{}

	call(bobik)
	call(grisha)
}
```